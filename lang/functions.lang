#============================
# function declarations
#============================

  a: ([b c] b + c)
  
  (a 1 2)
  
  # => 3
  
  # looking at it more closely...
  
  a: ([b c] b + c)

  #  ^           ^   the parentheses themselves represent an invocation
  #                    however, since the first element of the invocation is a list,
  #                    it can be thought of as a deferred
  #   ^^^^^          a block as the first element of an invocation declares bindable symbols
  #         ^^^^^    the rest of the invocation behaves normally

  # since the parameter declaration behaves as a normal block, symbols
  # can be constrained to types, etc
  
  a: ([b:Int c] b + c)
  
  
#============================
# why not calling style X?
#============================

  #*
  One of the harder issues to deal with in programming language design is managing
  the trade-offs between doing a few things well versus doing most things average.
  
  To quote Antoine de Saint-Exupery:
  "A designer knows he has arrived at perfection not when there is no longer anything to add,
     but when there is no longer anything to take away."
       (Programming Pearls, Second Edition, p. 7)
  
  In this sense, one goal of [language] was to reduce the *number of things*.
  
  LISP-like language take this to the extreme with S-expressions, in that data and code are
  both constructed from cons cells.  While this does make rewriting S-expressions and generating
  new code at runtime more straightforward, it doesn't change the fact that the code must at
  some point be evaluated and made sense of by both machine and human alike.
  
  
  
  *#

  # let's declare the same function a couple different ways
  #   (a C-like language and a Scheme-like language)
  # and an object

  function hello(name)
  {
    return "Hello " + name;
  }
  
  (define hello (lambda [name] (append "Hello " name) ) )
  
  class Vector3f( x:Float y:Float z:Float )
  {
  	operator + (Vector3f other)
  	{
  	    return new Vector3f {
  		  x: this.x + other.x
  		  y: this.y + other.y
  		  z: this.z + other.z
  		};
  	}
  	
  	Vector3f project(Matrix m)
  	{
  	  ...
  	  return projected;
  	}
  }
 
  # define two vectors
  v1 := Vector3f( 1, 2, 3 );
  v2 := Vector3f( 1, 2, 3 );
  
  v3 := v1 + v2         # invokes the '+' operator
  v4 := v1.project(v2)  # calls the 'project' method

  
  
  
  