
a: [ b c | b + c ]

a: [| 3 ]

#============================

a: [ b |
	this.bind: [ callsite | assert b.type = Int ]    # only re-evaluate expressions when dependent values change
							#      ^ this has scope of function, so 'b' can be directly referenced
							#             ^ since ':' is assign, '=' can be equal
	b + 2]

 # OR

a: [ b | b + 2 ]
a.bind: [ callsite | assert b.type = Int ]

 # OR

a: [ b:Int | b + 2 ]
	# ^ this is a bind, Int is a function with certain bind properties

#============================

add: [ :b + :a ]

add b:1 a:2

  # this is a little silly though, since the order of the arguments
  # is not significant and the names generally would not provide
  # any additional description
  
  # ideally (and in many other languages), this would just be:

add(1 2)

  # and there is no reason to model this any differently.
  # The arguments are identified by their ordinal (0 and 1, respectively)
  # and that can serve as their implicit 'name' as well.
  #  
  # If the same function invocation as above was made explicitly,
  # if would be:

add( 0:1 1:2 )

  # this stays consistent with the philosophy that everything
  # is a map of keys to values, and arrays are just a special
  # case where the keys are sequential integers starting at 0

#============================

add: [ b + a ]

# => add<function<a: b:>>

  # add has two unbound symbols, 'b' and 'a'

newAdd: add( b:2 )

# => newAdd<function<a:Int>>

  # newAdd is add with the 'b' bound to 2, so now only 'a' is unbound
  # however, binding 'b' to 2 also binds '+' to 2, which probably
  # imposed some restrictions on 'a' (like requiring that it must be an integer)

newAdd( a: 3 )

# => 5


#============================
# ambiguity of message sends
#============================
 
 # integer class with a 'plus' method that takes another Int  (make This the type of this?)
Int: [ plus:[ other:Int | <primitive-add this + other> ] ]

 # and bind the symbol 'plus' in the scope
a: 3
b: 2
plus: 4


d: [ b plus a ]

    # is 'd' a list of integers or is the method 'plus'
    # of the symbol 'b' (of type Int) being invoked with ordinal
    # parameter 'a'?
    
d: (b plus a)

e: ( (b plus a) plus d )



#============================
# constrained types
#============================

  Person: [ name:Str  age:(Int > 0) ]
  
  p: (Person name:'Brian' age:28)
  
  Person: ([ name:Str  age:Int ] where:[ (age > 0) ])

#============================
# boolean expressions
#============================

  b: false
  c: true
  d: false
  
  a: (b and c or d)
  
  # read as  a -> b.and(c).or(d)
  #      also   ((b and c) or d)
  #
  # evaluated as a normal function invocation


#============================
# TODO references
#============================

  # using the boolean example:

  b: false
  c: true
  d: false
  
  a: (b and c or d)
  
  # is the symbol 'a' bound to a symbol or a function?
  
  # in this case it is a value, since 


#============================


  a: [a b| (a + b)]



#============================

Person: [ this.name = :name ]

p: Person name:'Brian'

#============================

Person: [ name | this.name = name ]

p: Person name: 'Brian'

a: [ Person name: 'Brian' ]

b: [ p [ a ] ]




