
a: 1           # (def a 1)
a: 2 b: 3      # (def (a 2) (b 3))

#============================

a: 1 b: 2 c: 3

z: [a b c]

#============================

z: [fn [a b] [ a + b ] ]
z: fn [a b] a + b

#============================   

z: [a b] => a + b

# in reality, this is all contained in a list
z: [ [a b] => a + b ]

# each element of the list is evaluated within the context of the
# partially evaluated result of the preceding element

z: [ [a [b]] => a + b ]
          ^^ a list of symbols is emitted from this cell

z: [ [a [b]] [=> a + b ] ]
#             ^^ '=>' in the context of a list of symbols means a lambda,
#                in the sense that a list is being applied to another list (whatever follows)

z: [ [a [b]] [=> [a + b ] ] ]
#                 ^ lambda accepts any subsequent list element

z: [ [a [b]] [=> [a [+ b ] ] ] ]
#                    ^ 



z: [ [ a [ b ] ] [ => [ a [ + [ b ] ] ] ] ]

                        ^ with type Any, this becomes a dynamic dispatch ('+')
                        ^ with type Duck, this constraints 'a' to a type
                          that accepts '+' with 'b' as a parameter
                            - and constraints 'b' to the type that
                              the 'a' type accepts

SomeType: [ +: => print "Hello" ]

a: SomeType

z: [ [ a [ b ] ] [ => [ a [ + [ b ] ] ] ] ]

#   this won't work, since the '+' in SomeType doesn't take an argument


#============================

# a Type is a function that takes a callsite as a parameter

person: Int

a: [ 


#============================



b: [ a b | a + b ]


[b 1 2] 
